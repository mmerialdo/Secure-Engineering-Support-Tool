/* --------------------------------------------------------------------------------------------------------------------
// Copyright file="ThreatModelManagerInput.java"
//  © Copyright European Space Agency, 2018-2020
//
//  Author: Software developed by RHEA System S.A.
//
//  This file is subject to the terms and conditions defined in file 'LICENSE.txt', which is part of this source code package.
//  No part of the package, including this file, may be copied, modified, propagated, or distributed
//  except according to the terms contained in the file ‘LICENSE.txt’.
// --------------------------------------------------------------------------------------------------------------------
*/
package org.crmf.core.vulnerabilitymodel.manager;


import org.crmf.model.general.SESTObject;
import org.crmf.model.riskassessment.AssessmentProcedure;
import org.crmf.model.riskassessment.VulnerabilityModel;
import org.crmf.model.riskassessmentelements.Vulnerability;
import org.crmf.model.utility.GenericFilter;
import org.crmf.model.utility.GenericFilterEnum;
import org.crmf.model.utility.ModelObject;
import org.crmf.model.utility.TaxonomyReferenceBuilder;
import org.crmf.persistency.domain.vulnerability.SestVulnerabilityModel;
import org.crmf.persistency.mapper.general.SestObjServiceInterface;
import org.crmf.persistency.mapper.project.AssprocedureServiceInterface;
import org.crmf.persistency.mapper.vulnerability.VulnerabilityServiceInterface;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class VulnerabilityModelManagerInputTest {
  @Mock
  private VulnerabilityServiceInterface vulnerabilityService;
  @Mock
  private AssprocedureServiceInterface assprocedureService;
  @Mock
  private SestObjServiceInterface sestObjService;
  @Mock
  private TaxonomyReferenceBuilder taxonomyReferenceBuilder;

  @InjectMocks
  private VulnerabilityModelManagerInput manager;

  @BeforeEach()
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void editVulnerabilityModel() {
    String vulnerabilityModelJson = "this is a vulnerability model json for test";
    String vulnerabilityModelIdentifier = UUID.randomUUID().toString();

    manager.editVulnerabilityModel(vulnerabilityModelJson, vulnerabilityModelIdentifier);
    verify(vulnerabilityService, times(1)).update(vulnerabilityModelJson, vulnerabilityModelIdentifier);
  }

  @Test
  public void loadVulnerabilityModel() throws Exception {

    String procedureIdentifier = "procedureID";
    String vulnerabilityIdentifier = "procedureID";

    Map<GenericFilterEnum, String> filterMap = new HashMap<>();
    filterMap.put(GenericFilterEnum.PROCEDURE, procedureIdentifier);
    GenericFilter filter = new GenericFilter();
    filter.setFilterMap(filterMap);

    VulnerabilityModel vulnerabilityModel = new VulnerabilityModel();
    vulnerabilityModel.setIdentifier(vulnerabilityIdentifier);
    SestVulnerabilityModel vulnerabilityModelDb = new SestVulnerabilityModel();
    vulnerabilityModelDb.setSestobjId(vulnerabilityIdentifier);
    vulnerabilityModelDb.setVulnerabilityModelJson("this is a vulnerability model for test");
    AssessmentProcedure procedure = new AssessmentProcedure();
    procedure.setIdentifier(procedureIdentifier);
    procedure.setVulnerabilityModel(vulnerabilityModel);
    SESTObject sestObject = new SESTObject();
    sestObject.setIdentifier(vulnerabilityIdentifier);
    sestObject.setLockedBy("someUserLocking");

    ModelObject modelObjectExpected = new ModelObject();
    modelObjectExpected.setJsonModel("this is a vulnerability model for test");
    modelObjectExpected.setObjectIdentifier(vulnerabilityIdentifier);
    modelObjectExpected.setLockedBy("someUserLocking");

    when(assprocedureService.getByIdentifierFull(procedureIdentifier)).thenReturn(procedure);
    when(vulnerabilityService.getByIdentifier(vulnerabilityIdentifier)).thenReturn(vulnerabilityModelDb);
    when(sestObjService.getByIdentifier(vulnerabilityIdentifier)).thenReturn(sestObject);

    ModelObject modelObjectReturn = manager.loadVulnerabilityModel(filter);

    Assertions.assertEquals(modelObjectExpected.getJsonModel(), modelObjectReturn.getJsonModel());
    Assertions.assertEquals(modelObjectExpected.getObjectIdentifier(), modelObjectReturn.getObjectIdentifier());
    Assertions.assertEquals(modelObjectExpected.getLockedBy(), modelObjectReturn.getLockedBy());
  }

  @Test
  public void loadVulnerabilityModelNullProcedure() {
    GenericFilter filter = new GenericFilter();
    filter.setFilterMap(new HashMap<>());

    Assertions.assertThrows(Exception.class, () -> {
      manager.loadVulnerabilityModel(filter);
    });
  }

  @Test
  public void loadVulnerabilityRepository() {

    Map<GenericFilterEnum, String> filterMap = new HashMap<>();
    filterMap.put(GenericFilterEnum.METHODOLOGY, "MEHARI");
    GenericFilter filter = new GenericFilter();
    filter.setFilterMap(filterMap);
    SestVulnerabilityModel vulnerabilityModel = new SestVulnerabilityModel();
    vulnerabilityModel.setVulnerabilityModelJson("this is a vulnerability model for test");

    when(vulnerabilityService.getVulnerabilityRepository("MEHARI")).thenReturn(vulnerabilityModel);

    String vulnerabilityRepositoryJson = manager.loadVulnerabilityRepository(filter);

    Assertions.assertEquals("this is a vulnerability model for test", vulnerabilityRepositoryJson);
  }

  @Test
  public void createVulnerability() throws Exception {

    Vulnerability vulnerability = new Vulnerability();
    vulnerability.setName("someVulnerabilityName");
    Vulnerability vulnerabilityChecked = new Vulnerability();
    vulnerabilityChecked.setName("someVulnerabilityNameFull");
    when(taxonomyReferenceBuilder.vulnerabilityCheckAndFill(vulnerability)).thenReturn(vulnerabilityChecked);

    manager.createVulnerability(vulnerability);

    verify(vulnerabilityService, times(1)).insertVulnerabilityReference(vulnerabilityChecked);
  }

  @Test
  public void editVulnerability() throws Exception {

    Vulnerability vulnerability = new Vulnerability();
    vulnerability.setName("someVulnerabilityName");
    Vulnerability vulnerabilityChecked = new Vulnerability();
    vulnerabilityChecked.setName("someVulnerabilityNameFull");
    when(taxonomyReferenceBuilder.vulnerabilityCheckAndFill(vulnerability)).thenReturn(vulnerabilityChecked);

    manager.editVulnerability(vulnerability);

    verify(vulnerabilityService, times(1)).editVulnerabilityReference(vulnerabilityChecked);
  }

  @Test
  public void deleteVulnerability() throws Exception {
    List<String> identifiers = new ArrayList<>();
    identifiers.add("identifier1");
    identifiers.add("identifier2");

    manager.deleteVulnerability(identifiers);

    verify(vulnerabilityService, times(1)).deleteVulnerabilityReference(identifiers);
  }
}
