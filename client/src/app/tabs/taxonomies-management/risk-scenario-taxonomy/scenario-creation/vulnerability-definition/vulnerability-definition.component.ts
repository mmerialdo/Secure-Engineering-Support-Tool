/* --------------------------------------------------------------------------------------------------------------------
  // Copyright file="vulnerability-definition.component.ts"
  //  © Copyright European Space Agency, 2018-2020
  //
  //  Author: Software developed by RHEA System S.A.
  //
  //  This file is subject to the terms and conditions defined in file 'LICENSE.txt', which is part of this source code package.
  //  No part of the package, including this file, may be copied, modified, propagated, or distributed
  //  except according to the terms contained in the file ‘LICENSE.txt’.
  // --------------------------------------------------------------------------------------------------------------------
  */

import {Component, EventEmitter, Input, OnInit, Output} from '@angular/core';
import {ImpactTypeEnum, VulnerabilityTaxonomy} from "../../../taxonomiesManagement.model";
import {VulnerabilitiesTaxonomyService} from "../../../vulnerabilities-taxonomy/vulnerabilities-taxonomy.service";
import {BehaviorSubject, combineLatest, Observable} from "rxjs";
import {map, tap} from "rxjs/operators";

@Component({
  selector: 'app-vulnerability-definition',
  templateUrl: './vulnerability-definition.component.html',
  providers: [VulnerabilitiesTaxonomyService]
})
export class VulnerabilityDefinitionComponent implements OnInit {
  @Input() vulnerabilityData: VulnerabilityTaxonomy;
  @Input() assetDetail: {assetType: string, supportingAsset: {value: string}, aice: string}
  @Output() vulnerabilityDetails: EventEmitter<any> = new EventEmitter();
  vulnerabilities$: Observable<VulnerabilityTaxonomy[]>;
  selectedTaxonomy;
  showPopup = false;
  filteredVulnerabilities$;

  filterCategory$: BehaviorSubject<{value:string}[]> = new BehaviorSubject([]);
  filterImpact$: BehaviorSubject<string> = new BehaviorSubject("");

  impacts = Object.keys(ImpactTypeEnum).map( key => ImpactTypeEnum[key]).map((value) => ({
    label: value,
    value: value
  }));


  constructor(private vulnerabilitiesService: VulnerabilitiesTaxonomyService) {

  }

  ngOnInit() {

    this.vulnerabilitiesService.fetch$().subscribe();
    this.vulnerabilities$ = this.vulnerabilitiesService.vulnerabilities;

    this.filterCategory$.next([this.assetDetail.supportingAsset]);
    this.filterImpact$.next(this.assetDetail.aice);


    this.filteredVulnerabilities$ = this.createFilterVulnerabilities(
      this.filterCategory$,
      this.filterImpact$,
      this.vulnerabilities$
    ).pipe(
      tap((response) => {
        if(this.vulnerabilityData !== undefined) {
          this.selectedTaxonomy = response.filter(vulnerability => vulnerability.name === this.vulnerabilityData.name)[0];
        }
        this.vulnerabilityDetails.emit(this.selectedTaxonomy);
      }),
      map(response => response)
    );

  }

  onSelect() {
    this.vulnerabilityDetails.emit(this.selectedTaxonomy)
  }

  onDeselect() {
    this.vulnerabilityDetails.emit(null);
  }

  onClose(event) {
    this.showPopup = false;
  }

  showDialog() {
    this.showPopup = true;
  }

  createFilterVulnerabilities(filterCategory$, filterImpact$, vulnerabilities$) {

    return combineLatest(
      vulnerabilities$,
      filterCategory$,
      filterImpact$,(vulnerabilities: VulnerabilityTaxonomy[], filterCategory: {value: string}[], filterImpact: string) => {

        if (filterCategory.length === 0) return vulnerabilities;
        return vulnerabilities.filter(vulnerability => {
          if (filterImpact !== "") {
            return vulnerability.affectedAssetsCategories.some(category =>
              filterCategory.map(f => f.value).includes(category)) &&
              vulnerability.score.consequences[0].securityImpacts.some(impact =>
              impact.scope === filterImpact);
          } else {
            return vulnerability.affectedAssetsCategories.some(category =>
              filterCategory.map(f => f.value).includes(category));
          }
        })
      });
  }

}
