/* --------------------------------------------------------------------------------------------------------------------
// Copyright file="ThreatImportManagerInput.java"
//  © Copyright European Space Agency, 2018-2020
//
//  Author: Software developed by RHEA System S.A.
//
//  This file is subject to the terms and conditions defined in file 'LICENSE.txt', which is part of this source code package.
//  No part of the package, including this file, may be copied, modified, propagated, or distributed
//  except according to the terms contained in the file ‘LICENSE.txt’.
// --------------------------------------------------------------------------------------------------------------------
*/

package org.crmf.proxy.core.vulnerabilitymodel.manager.rest;

import org.crmf.model.exception.RemoteComponentException;
import org.crmf.persistency.domain.vulnerability.SestVulnerabilityModel;
import org.crmf.persistency.mapper.vulnerability.VulnerabilityServiceInterface;
import org.crmf.proxy.authnauthz.Permission;
import org.crmf.proxy.configuration.ApiExceptionEnum;
import org.crmf.vulnerabilityimport.vulnerabilityimportmanager.VulnerabilityImportManagerInput;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.InputStreamResource;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

@RestController
@RequestMapping(value = "api/vulnerability")
public class VulnerabilityImportExportRestServer {

  private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityImportExportRestServer.class.getName());

  @Autowired
  private VulnerabilityServiceInterface vulnerabilityService;
  @Autowired
  private VulnerabilityImportManagerInput vulnerabilityImportManager;

  @GetMapping("export")
  @Permission("Taxonomy:Read")
  public InputStreamResource exportVulnerabilities(@RequestParam(name = "SHIRO_SECURITY_TOKEN") String token) throws IOException {
    LOG.info("exportVulnerabilities ");
    FileOutputStream fos = null;
    File fileToReturn = new File("exportVulnerability.temp");
    fileToReturn.deleteOnExit();
    try {
      if (!fileToReturn.exists()) {
        boolean created = fileToReturn.createNewFile();
        if (!created) {
          LOG.error("Unable to create export Vulnerabilities file");
          return null;
        }
      }
      fos = new FileOutputStream(fileToReturn);
      SestVulnerabilityModel model = vulnerabilityService.getVulnerabilityRepository(null);
      if (model != null) {
        String vulnerabilityModel = model.getVulnerabilityModelJson();
        fos.write(vulnerabilityModel.getBytes());
      }
      return new InputStreamResource(new FileInputStream(fileToReturn));
    } catch (IOException ioe) {
      LOG.error("Unable to create file ", ioe);
    } finally {
      if (fos != null) {
        fos.close();
      }
      fileToReturn.delete();
    }
    return null;
  }


  @PostMapping("import")
  @Permission("Taxonomy:Read")
  public String importVulnerabilities(@RequestParam(name = "SHIRO_SECURITY_TOKEN") String token,
                                      @RequestParam("file") MultipartFile multipartFile) {
    try {
      vulnerabilityImportManager.importVulnerabilitiesFromInput(multipartFile.getInputStream());
    } catch (Exception e) {
      LOG.error("=========== import vulnerabilities error " + e.getMessage());
      throw new RemoteComponentException(ApiExceptionEnum.COMMAND_EXCEPTION, e);
    }
    return "";
  }
}
