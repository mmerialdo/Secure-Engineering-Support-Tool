/* --------------------------------------------------------------------------------------------------------------------
// Copyright file="VulnerabilityImportManagerInput.java"
//  © Copyright European Space Agency, 2018-2020
//
//  Author: Software developed by RHEA System S.A.
// 
//  This file is subject to the terms and conditions defined in file 'LICENSE.txt', which is part of this source code package. 
//  No part of the package, including this file, may be copied, modified, propagated, or distributed 
//  except according to the terms contained in the file ‘LICENSE.txt’.
// --------------------------------------------------------------------------------------------------------------------
*/

package org.crmf.vulnerabilityimport.vulnerabilityimportmanager;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import org.apache.cxf.jaxrs.ext.multipart.Attachment;

import org.crmf.model.exception.RemoteComponentException;
import org.crmf.model.riskassessment.VulnerabilityModel;
import org.crmf.model.riskassessmentelements.Vulnerability;
import org.crmf.model.riskassessmentelements.VulnerabilitySourceEnum;
import org.crmf.model.utility.vulnerabilitymodel.VulnerabilityModelSerializerDeserializer;
import org.crmf.persistency.mapper.vulnerability.VulnerabilityServiceInterface;
import org.ini4j.Wini;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class VulnerabilityImportManagerInput implements VulnerabilityImportManagerInputInterface {

	// Vulnerability service variable of persistency component
	private VulnerabilityServiceInterface vulnerabilityService;

	private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityImportManagerInput.class.getName());
	private String fileName;
	private String url;
	private VulnerabilityModel vmToAdd;
	private VulnerabilityModel vmToUpdate;

	//Actually, the only implemented threat vulnerability source is a JSON file
    //The method could be easily extended in order to import taxonomies also from other sources
	@Override
	public void importVulnerabilities(VulnerabilitySourceEnum source) throws Exception {

		LOG.info("importVulnerabilities -  source: " + source.toString());

		fileName = "";
		url = "";

		loadConfiguredVulnerabilityCatalogues(source.toString());
		VulnerabilityModel vm = new VulnerabilityModel();
		if(fileName != null && !fileName.equals("")) {
			vm = loadVulnerabilitiesFromFile(source);
		} else if(url != null && !url.equals("")) {
			//TODO
		} else {
			throw new RemoteComponentException("Vulnerability Catalogue not supported");
		}
		importVulnerabilitiesWithUpdate(source, vm);
	}

	public void importVulnerabilitiesFromInput(Attachment attachmentFile) throws Exception {
		VulnerabilityModel model = loadMehariVulnerabilitiesFromInput(attachmentFile.getObject(InputStream.class));
		importVulnerabilitiesWithUpdate(null, model);
	}

	private void importVulnerabilitiesWithUpdate(VulnerabilitySourceEnum source, VulnerabilityModel vm) throws Exception {
		if(vm == null || vm.getVulnerabilities() == null || vm.getVulnerabilities().size() == 0){
			LOG.info("Vulnerability Catalogue empty");
			throw new RemoteComponentException("Vulnerability Catalogue empty");
		}

		//In this moment I have a VulnerabilityModel with a set of vulnerability just imported
		//Now I need to updateQuestionnaireJSON the database.
		//At first i load all existing vulnerabilities for the selected source
		VulnerabilityModel savedVm = vulnerabilityService.getVulnerabilityRepository(source != null ? source.toString() : null).convertToModel();

		//Here I create 2 VulnerabilityModels: the first will collect all vulnerabilities I have to add, the other all already existing vulnerabilities which I have to updateQuestionnaireJSON
		vmToAdd = new VulnerabilityModel();
		vmToUpdate = new VulnerabilityModel();

		compareVulnerabilityRepositories(vm, savedVm);

		if(vulnerabilityService.updateVulnerabilityRepository(vmToAdd, vmToUpdate)){
			LOG.info("importVulnerabilities successful");
		}
		else{
			LOG.info("importVulnerabilities failed");
			throw new Exception("COMMAND_EXCEPTION");
		}
	}

	private void compareVulnerabilityRepositories(VulnerabilityModel vm, VulnerabilityModel savedVm) {

		LOG.info("compareVulnerabilityRepositories " + vm.getVulnerabilities().size());
		LOG.info("compareVulnerabilityRepositories " + savedVm.getVulnerabilities().size());

		for (Vulnerability newVulnerability : vm.getVulnerabilities()) {

			LOG.info("compareVulnerabilityRepositories 1 " + newVulnerability.getCatalogueId());
			boolean alreadyExisting = false;
			boolean toBeUpdated = false;
			for (Vulnerability oldVulnerability : savedVm.getVulnerabilities()) {
				LOG.info("compareVulnerabilityRepositories 2 " + oldVulnerability.getCatalogueId());

				if(newVulnerability.getCatalogueId().equals(oldVulnerability.getCatalogueId())){
					alreadyExisting = true;
					LOG.info("compareVulnerabilityRepositories alreadyExisting " + alreadyExisting);

					if(compareVulnerabilities(oldVulnerability, newVulnerability)){
						newVulnerability.setIdentifier(oldVulnerability.getIdentifier());
						toBeUpdated = true;
						LOG.info("compareVulnerabilityRepositories toBeUpdated " + toBeUpdated);
					}
					break;
				}
			}
			if(!alreadyExisting){
				vmToAdd.getVulnerabilities().add(newVulnerability);
			}
			if(toBeUpdated){
				vmToUpdate.getVulnerabilities().add(newVulnerability);
			}
		}
	}

	private boolean compareVulnerabilities(Vulnerability oldVulnerability, Vulnerability newVulnerability) {

		DateFormat df = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		try {
			Date oldVulnerabilityDate = df.parse(oldVulnerability.getLastUpdate());
			Date newVulnerabilityDate = df.parse(newVulnerability.getLastUpdate());

			if(newVulnerabilityDate.compareTo(oldVulnerabilityDate) > 0){
				return true;
			}
			else{
				return false;
			}
		} catch (ParseException e) {
			LOG.error("loadVulnerabilities " + e.getMessage());
			return true;
		}
	}

	private VulnerabilityModel loadVulnerabilitiesFromFile(VulnerabilitySourceEnum source) throws IOException {
		switch(source){
		case MEHARI:
			return loadMehariVulnerabilitiesFromFile();
		case CWE:
			return null;
		default:
			return null;
		}

	}

	private VulnerabilityModel loadMehariVulnerabilitiesFromInput(InputStream is) throws IOException {
		try{
			byte[] bamJson = new byte[is.available()];
			is.read(bamJson);
			String vmJsonString = new String(bamJson, "UTF-8");
			LOG.info("loadVulnerabilitiesFromFile " + vmJsonString);
			VulnerabilityModelSerializerDeserializer vmSerDes = new VulnerabilityModelSerializerDeserializer();
			VulnerabilityModel vm = vmSerDes.getVMFromJSONString(vmJsonString);

			return vm;

		}
		catch(Exception e){
			LOG.error("loadVulnerabilities " + e.getMessage());
			return null;
		}
	}

	private VulnerabilityModel loadMehariVulnerabilitiesFromFile() throws IOException {
		try{
		File fvmJson = new File(fileName);
		byte[] bamJson = Files.readAllBytes(fvmJson.toPath());
		String vmJsonString = new String(bamJson, "UTF-8");

		LOG.info("loadVulnerabilitiesFromFile " + vmJsonString);

		VulnerabilityModelSerializerDeserializer vmSerDes = new VulnerabilityModelSerializerDeserializer();

		VulnerabilityModel vm = vmSerDes.getVMFromJSONString(vmJsonString);

		return vm;
		}
		catch(Exception e){
			LOG.error("loadVulnerabilities " + e.getMessage());
			return null;
		}
	}


	public void loadConfiguredVulnerabilityCatalogues(String catalogue){
		Wini iniVuln;

		try {
			iniVuln = new Wini(new File("vulnCatalogue.ini"));

			fileName = iniVuln.get(catalogue, "fileName");
			url = iniVuln.get(catalogue, "url");



		}catch(IOException ex){
			LOG.error("loadConfiguredVulnerabilityCatalogues " + ex.getMessage());
		}
	}


	public VulnerabilityServiceInterface getVulnerabilityService() {
		return vulnerabilityService;
	}


	public void setVulnerabilityService(VulnerabilityServiceInterface vulnerabilityService) {
		this.vulnerabilityService = vulnerabilityService;
	}



}
