/* --------------------------------------------------------------------------------------------------------------------
// Copyright file="VulnerabilityImportManagerInput.java"
//  © Copyright European Space Agency, 2018-2020
//
//  Author: Software developed by RHEA System S.A.
// 
//  This file is subject to the terms and conditions defined in file 'LICENSE.txt', which is part of this source code package. 
//  No part of the package, including this file, may be copied, modified, propagated, or distributed 
//  except according to the terms contained in the file ‘LICENSE.txt’.
// --------------------------------------------------------------------------------------------------------------------
*/

package org.crmf.vulnerabilityimport.vulnerabilityimportmanager;

import org.crmf.model.exception.RemoteComponentException;
import org.crmf.model.riskassessment.VulnerabilityModel;
import org.crmf.model.riskassessmentelements.Vulnerability;
import org.crmf.model.utility.vulnerabilitymodel.VulnerabilityModelSerializerDeserializer;
import org.crmf.persistency.mapper.vulnerability.VulnerabilityService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

@Service
public class VulnerabilityImportManagerInput {

  private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityImportManagerInput.class.getName());
  // Vulnerability service variable of persistency component
  @Autowired
  private VulnerabilityService vulnerabilityService;

  public static final String DD_MM_YYYY_HH_MM = "dd/MM/yyyy HH:mm";

  public void importVulnerabilitiesFromInput(InputStream file) throws Exception {
    VulnerabilityModel model = loadMehariVulnerabilitiesFromInput(file);
    importVulnerabilitiesWithUpdate(model);
  }

  private void importVulnerabilitiesWithUpdate(VulnerabilityModel vm) throws Exception {
    if (vm == null || vm.getVulnerabilities() == null || vm.getVulnerabilities().isEmpty()) {
      LOG.info("Vulnerability Catalogue empty");
      throw new RemoteComponentException("Vulnerability Catalogue empty");
    }

    //In this moment I have a VulnerabilityModel with a set of vulnerability just imported
    //Now I need to updateQuestionnaireJSON the database.
    //At first i load all existing vulnerabilities for the selected source
    VulnerabilityModel savedVm = vulnerabilityService.getVulnerabilityRepository(null).convertToModel();

    //Here I create 2 VulnerabilityModels: the first will collect all vulnerabilities I have to add, the other all already existing vulnerabilities which I have to updateQuestionnaireJSON
    VulnerabilityModel vmToAdd = new VulnerabilityModel();
    VulnerabilityModel vmToUpdate = new VulnerabilityModel();

    compareVulnerabilityRepositories(vmToAdd, vmToUpdate, vm, savedVm);

    if (vulnerabilityService.updateVulnerabilityRepository(vmToAdd, vmToUpdate)) {
      LOG.info("importVulnerabilities successful");
    } else {
      LOG.info("importVulnerabilities failed");
      throw new Exception("unable to updateVulnerabilityRepository");
    }
  }

  private void compareVulnerabilityRepositories(VulnerabilityModel vmToAdd, VulnerabilityModel vmToUpdate,
                                                VulnerabilityModel vm, VulnerabilityModel savedVm) {

    LOG.info("compareVulnerabilityRepositories {}", vm.getVulnerabilities().size());
    LOG.info("compareVulnerabilityRepositories {}", savedVm.getVulnerabilities().size());

    for (Vulnerability newVulnerability : vm.getVulnerabilities()) {

      LOG.info("compareVulnerabilityRepositories 1 {}", newVulnerability.getCatalogueId());
      boolean alreadyExisting = false;
      boolean toBeUpdated = false;
      for (Vulnerability oldVulnerability : savedVm.getVulnerabilities()) {

        if (newVulnerability.getCatalogueId().equals(oldVulnerability.getCatalogueId())) {
          alreadyExisting = true;
          LOG.info("compareVulnerabilityRepositories alreadyExisting {}", alreadyExisting);

          if (compareVulnerabilities(oldVulnerability, newVulnerability)) {
            newVulnerability.setIdentifier(oldVulnerability.getIdentifier());
            toBeUpdated = true;
            LOG.info("compareVulnerabilityRepositories toBeUpdated {}", toBeUpdated);
          }
          break;
        }
      }
      if (!alreadyExisting) {
        vmToAdd.getVulnerabilities().add(newVulnerability);
      }
      if (toBeUpdated) {
        vmToUpdate.getVulnerabilities().add(newVulnerability);
      }
    }
  }

  private boolean compareVulnerabilities(Vulnerability oldVulnerability, Vulnerability newVulnerability) {

    DateFormat df = new SimpleDateFormat(DD_MM_YYYY_HH_MM);
    try {
      Date oldVulnerabilityDate = df.parse(oldVulnerability.getLastUpdate());
      Date newVulnerabilityDate = df.parse(newVulnerability.getLastUpdate());

      return (newVulnerabilityDate.compareTo(oldVulnerabilityDate) > 0) ? true : false;
    } catch (ParseException e) {
      LOG.error("compareVulnerabilities {}", e.getMessage());
      return true;
    }
  }

  private VulnerabilityModel loadMehariVulnerabilitiesFromInput(InputStream is) throws Exception {
    try {
      byte[] bamJson = new byte[is.available()];
      Integer bytesNumber = is.read(bamJson);
      if (bytesNumber > 0) {
        String vmJsonString = new String(bamJson, StandardCharsets.UTF_8);
        VulnerabilityModelSerializerDeserializer vmSerDes = new VulnerabilityModelSerializerDeserializer();
        return vmSerDes.getVMFromJSONString(vmJsonString);
      }
    } catch (Exception e) {
      LOG.error("loadMehariVulnerabilitiesFromInput {}", e.getMessage());
      throw new RemoteComponentException("Vulnerability file read error");
    }
    return null;
  }
}
