import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.crmf.model.exception.RemoteComponentException;
import org.crmf.model.riskassessment.VulnerabilityModel;
import org.crmf.model.riskassessmentelements.Vulnerability;
import org.crmf.model.riskassessmentelements.VulnerabilitySourceEnum;
import org.crmf.model.utility.vulnerabilitymodel.VulnerabilitySerializerDeserializer;
import org.crmf.persistency.domain.vulnerability.SestVulnerabilityModel;
import org.crmf.persistency.mapper.vulnerability.VulnerabilityService;
import org.crmf.vulnerabilityimport.vulnerabilityimportmanager.VulnerabilityImportManagerInput;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.core.io.ClassPathResource;
import org.springframework.util.ResourceUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;

import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.lenient;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class VulnerabilityImportManagerInputTest {

  @InjectMocks
  VulnerabilityImportManagerInput vulnerabilityImportManager;

  @Mock
  VulnerabilityService vulnerabilityService;

  public static final String DD_MM_YYYY_HH_MM = "dd/MM/yyyy HH:mm";
  private static final DateFormat df = new SimpleDateFormat(DD_MM_YYYY_HH_MM);

  @BeforeEach()
  public void initMocks() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void importVulnerabilitiesInsert() throws Exception {

    GsonBuilder gsonBuilder = new GsonBuilder();
    JsonObject jsonObjectExisting = new JsonObject();
    JsonArray jsonArrayExisting = new JsonArray();
    jsonObjectExisting.add("vulnerabilities", jsonArrayExisting);
    jsonObjectExisting.addProperty("creationTime", "");
    jsonObjectExisting.addProperty("updateTime", "");
    jsonObjectExisting.addProperty("identifier", "");
    jsonObjectExisting.addProperty("objType", "VulnerabilityModel");
    SestVulnerabilityModel sestVulnerabilityModelExisting = new SestVulnerabilityModel();
    sestVulnerabilityModelExisting.setVulnerabilityModelJson(jsonObjectExisting.toString());

    Vulnerability v1 = new Vulnerability();
    v1.setLastUpdate("15/09/2020 15:00");
    v1.setCatalogue(VulnerabilitySourceEnum.MEHARI);
    v1.setCatalogueId("Cfl.alt");
    v1.setName("Cfl.alt");
    v1.setDescription("Alteration");
    Vulnerability v2 = new Vulnerability();
    v2.setLastUpdate("15/09/2020 15:00");
    v2.setCatalogueId("Cfl.bug");
    v2.setCatalogue(VulnerabilitySourceEnum.MEHARI);
    v2.setName("Cfl.bug");
    v2.setDescription("Failure");

    ArrayList vulnerabilities = new ArrayList();
    vulnerabilities.add(v1);
    vulnerabilities.add(v2);
    VulnerabilityModel modelToAdd = new VulnerabilityModel();
    modelToAdd.setVulnerabilities(vulnerabilities);
    modelToAdd.setUpdateTime("");
    modelToAdd.setCreationTime("");
    VulnerabilityModel modelToUpdate = new VulnerabilityModel();
    modelToUpdate.setVulnerabilities(new ArrayList<>());

    lenient().when(vulnerabilityService.getVulnerabilityRepository(null)).thenReturn(sestVulnerabilityModelExisting);

    when(vulnerabilityService.updateVulnerabilityRepository(
      argThat(new VulnerabilityMatcher(modelToAdd)), argThat(new VulnerabilityMatcher(modelToUpdate)))).thenReturn(true);

    InputStream resource = new ClassPathResource("vulnerability.json").getInputStream();
    // call importVulnerabilitiesFromInput to test
    vulnerabilityImportManager.importVulnerabilitiesFromInput(resource);

    verify(vulnerabilityService, times(1)).updateVulnerabilityRepository(
      argThat(new VulnerabilityMatcher(modelToAdd)), argThat(new VulnerabilityMatcher(modelToUpdate)));
  }

  @Test
  public void importVulnerabilitiesUpdate() throws Exception {

    Vulnerability vExisting = new Vulnerability();
    vExisting.setLastUpdate("15/09/2020 14:59");
    vExisting.setCatalogueId("Cfl.alt");
    Vulnerability vExisting2 = new Vulnerability();
    vExisting2.setLastUpdate("15/09/2020 15:01");
    vExisting2.setCatalogueId("Cfl.bug");
    VulnerabilitySerializerDeserializer deserializer = new VulnerabilitySerializerDeserializer();
    String vExistingJson = deserializer.getJSONStringFromVM(vExisting);
    String vExistingJson2 = deserializer.getJSONStringFromVM(vExisting2);

    GsonBuilder gsonBuilder = new GsonBuilder();
    Gson gson = gsonBuilder.create();
    JsonObject jsonObjectExisting = new JsonObject();
    JsonArray jsonArrayExisting = new JsonArray();
    JsonElement element1 = gson.fromJson(vExistingJson, JsonElement.class);
    JsonElement element2 = gson.fromJson(vExistingJson2, JsonElement.class);
    jsonArrayExisting.add(element1);
    jsonArrayExisting.add(element2);

    jsonObjectExisting.add("vulnerabilities", jsonArrayExisting);
    jsonObjectExisting.addProperty("creationTime", "");
    jsonObjectExisting.addProperty("updateTime", "");
    jsonObjectExisting.addProperty("identifier", "");
    jsonObjectExisting.addProperty("objType", "VulnerabilityModel");
    SestVulnerabilityModel sestVulnerabilityModelExisting = new SestVulnerabilityModel();
    sestVulnerabilityModelExisting.setVulnerabilityModelJson(jsonObjectExisting.toString());

    Vulnerability v1 = new Vulnerability();
    v1.setLastUpdate("15/09/2020 15:00");
    v1.setCatalogue(VulnerabilitySourceEnum.MEHARI);
    v1.setCatalogueId("Cfl.alt");
    v1.setName("Cfl.alt");
    v1.setDescription("Alteration");
    Vulnerability v2 = new Vulnerability();
    v2.setLastUpdate("15/09/2020 15:00");
    v2.setCatalogueId("Cfl.bug");
    v2.setCatalogue(VulnerabilitySourceEnum.MEHARI);
    v2.setName("Cfl.bug");
    v2.setDescription("Failure");

    ArrayList vulnerabilitiesToAdd = new ArrayList();
    ArrayList vulnerabilitiesToupdate = new ArrayList();
    vulnerabilitiesToupdate.add(v1);

    VulnerabilityModel modelToAdd = new VulnerabilityModel();
    modelToAdd.setVulnerabilities(vulnerabilitiesToAdd);
    VulnerabilityModel modelToUpdate = new VulnerabilityModel();
    modelToUpdate.setVulnerabilities(vulnerabilitiesToupdate);

    lenient().when(vulnerabilityService.getVulnerabilityRepository(null)).thenReturn(sestVulnerabilityModelExisting);

    when(vulnerabilityService.updateVulnerabilityRepository(
      argThat(new VulnerabilityMatcher(modelToAdd)), argThat(new VulnerabilityMatcher(modelToUpdate)))).thenReturn(true);

    InputStream resource = new ClassPathResource("vulnerability.json").getInputStream();
    // call importVulnerabilitiesFromInput to test
    vulnerabilityImportManager.importVulnerabilitiesFromInput(resource);

    verify(vulnerabilityService, times(1)).updateVulnerabilityRepository(
      argThat(new VulnerabilityMatcher(modelToAdd)), argThat(new VulnerabilityMatcher(modelToUpdate)));
  }

  @Test
  public void importVulnerabilitiesInsertAndUpdate() throws Exception {

    Vulnerability vExisting = new Vulnerability();
    vExisting.setLastUpdate("15/09/2020 14:59");
    vExisting.setCatalogueId("Cfl.alt");
    VulnerabilitySerializerDeserializer deserializer = new VulnerabilitySerializerDeserializer();
    String vExistingJson = deserializer.getJSONStringFromVM(vExisting);

    GsonBuilder gsonBuilder = new GsonBuilder();
    Gson gson = gsonBuilder.create();
    JsonObject jsonObjectExisting = new JsonObject();
    JsonArray jsonArrayExisting = new JsonArray();
    JsonElement element = gson.fromJson(vExistingJson, JsonElement.class);
    jsonArrayExisting.add(element);

    jsonObjectExisting.add("vulnerabilities", jsonArrayExisting);
    jsonObjectExisting.addProperty("creationTime", "");
    jsonObjectExisting.addProperty("updateTime", "");
    jsonObjectExisting.addProperty("identifier", "");
    jsonObjectExisting.addProperty("objType", "VulnerabilityModel");
    SestVulnerabilityModel sestVulnerabilityModelExisting = new SestVulnerabilityModel();
    sestVulnerabilityModelExisting.setVulnerabilityModelJson(jsonObjectExisting.toString());

    Vulnerability v1 = new Vulnerability();
    v1.setLastUpdate("15/09/2020 15:00");
    v1.setCatalogue(VulnerabilitySourceEnum.MEHARI);
    v1.setCatalogueId("Cfl.alt");
    v1.setName("Cfl.alt");
    v1.setDescription("Alteration");
    Vulnerability v2 = new Vulnerability();
    v2.setLastUpdate("15/09/2020 15:00");
    v2.setCatalogueId("Cfl.bug");
    v2.setCatalogue(VulnerabilitySourceEnum.MEHARI);
    v2.setName("Cfl.bug");
    v2.setDescription("Failure");

    ArrayList vulnerabilitiesToAdd = new ArrayList();
    vulnerabilitiesToAdd.add(v2);
    ArrayList vulnerabilitiesToupdate = new ArrayList();
    vulnerabilitiesToupdate.add(v1);

    VulnerabilityModel modelToAdd = new VulnerabilityModel();
    modelToAdd.setVulnerabilities(vulnerabilitiesToAdd);
    VulnerabilityModel modelToUpdate = new VulnerabilityModel();
    modelToUpdate.setVulnerabilities(vulnerabilitiesToupdate);

    lenient().when(vulnerabilityService.getVulnerabilityRepository(null)).thenReturn(sestVulnerabilityModelExisting);

    when(vulnerabilityService.updateVulnerabilityRepository(
      argThat(new VulnerabilityMatcher(modelToAdd)), argThat(new VulnerabilityMatcher(modelToUpdate)))).thenReturn(true);

    InputStream resource = new ClassPathResource("vulnerability.json").getInputStream();
    // call importVulnerabilitiesFromInput to test
    vulnerabilityImportManager.importVulnerabilitiesFromInput(resource);

    verify(vulnerabilityService, times(1)).updateVulnerabilityRepository(
      argThat(new VulnerabilityMatcher(modelToAdd)), argThat(new VulnerabilityMatcher(modelToUpdate)));
  }

  @Test
  public void importVulnerabilitiesWrongInput() throws Exception {

    Assertions.assertThrows(RemoteComponentException.class, () -> {
      vulnerabilityImportManager.importVulnerabilitiesFromInput(null);
    });
  }
}
