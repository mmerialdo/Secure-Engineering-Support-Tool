/* --------------------------------------------------------------------------------------------------------------------
// Copyright file="VulnerabilityService.java"
//  © Copyright European Space Agency, 2018-2020
//
//  Author: Software developed by RHEA System S.A.
// 
//  This file is subject to the terms and conditions defined in file 'LICENSE.txt', which is part of this source code package. 
//  No part of the package, including this file, may be copied, modified, propagated, or distributed 
//  except according to the terms contained in the file ‘LICENSE.txt’.
// --------------------------------------------------------------------------------------------------------------------
*/

package org.crmf.persistency.mapper.vulnerability;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import org.apache.ibatis.session.SqlSession;
import org.crmf.model.general.SESTObjectTypeEnum;
import org.crmf.model.riskassessment.VulnerabilityModel;
import org.crmf.model.riskassessmentelements.SecondaryAssetCategoryEnum;
import org.crmf.model.riskassessmentelements.Vulnerability;
import org.crmf.model.utility.vulnerabilitymodel.VulnerabilitySerializerDeserializer;
import org.crmf.persistency.domain.general.Sestobj;
import org.crmf.persistency.domain.vulnerability.SestVulnerability;
import org.crmf.persistency.domain.vulnerability.SestVulnerabilityModel;
import org.crmf.persistency.mapper.general.SestobjMapper;
import org.crmf.persistency.session.PersistencySessionFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.UUID;

//This class manages the database interactions related to Vulnerabilities
public class VulnerabilityService implements VulnerabilityServiceInterface {
  private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityService.class.getName());
  public static final String DD_MM_YYYY_HH_MM = "dd/MM/yyyy HH:mm";
  PersistencySessionFactory sessionFactory;

  @Override
  public void insert(String vulnerabilityModelJson, String sestobjId) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("Insert Vulnerability Model");

    Sestobj sestobj = null;

    try {
      //create a new Vulnerability Mapper
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      SestobjMapper sestobjMapper = sqlSession.getMapper(SestobjMapper.class);

      //create a new sestObj with the identifier in input and type VulnerabilityModel
      LOG.info("Insert sestObject");
      sestobj = new Sestobj();
      sestobj.setObjtype(SESTObjectTypeEnum.VulnerabilityModel.name());
      sestobj.setIdentifier(sestobjId);
      sestobjMapper.insertWithIdentifier(sestobj);


      //use the Vulnerability Mapper to insert the Vulnerability Model
      SestVulnerabilityModel vulnerabilityModel = new SestVulnerabilityModel();
      vulnerabilityModel.setVulnerabilityModelJson(vulnerabilityModelJson);
      vulnerabilityModel.setSestobjId(sestobjId);
      vulnerabilityMapper.insert(vulnerabilityModel);
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
    } finally {
      sqlSession.close();
    }

  }

  @Override
  public void update(String vulnerabilityModelJson, String identifier) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("updateQuestionnaireJSON Vulnerability Model " + vulnerabilityModelJson);

    try {
      //create a new Vulnerability Mapper
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      //use the Vulnerability Mapper to insert the Vulnerability Model
      vulnerabilityMapper.update(vulnerabilityModelJson, identifier);
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
    } finally {
      sqlSession.close();
    }

  }

  @Override
  public SestVulnerabilityModel getByIdentifier(String sestobjId) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("get By Identifier -  Vulnerability Model");
    SestVulnerabilityModel vulnModel;

    try {
      //create a new Vulnerability Mapper
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      //use the Vulnerability Mapper to insert the Vulnerability Model
      vulnModel = vulnerabilityMapper.getByIdentifier(sestobjId);
      LOG.info("get By Identifier -  Vulnerability Model returned: " + vulnModel);
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
      return null;
    } finally {
      sqlSession.close();
    }

    return vulnModel;
  }

  @Override
  public SestVulnerabilityModel getVulnerabilityRepository(String catalogue) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("getVulnerabilityRepository -  Vulnerability Model");
    SestVulnerabilityModel vulnModel;

    try {
      //create a new Vulnerability Mapper
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      //use the Vulnerability Mapper to load the vulnerability repository (in form of a list of Vulnerabilities)
      List<SestVulnerability> vulnerabilities = vulnerabilityMapper.getVulnerabilityRepository(catalogue);

      vulnModel = new SestVulnerabilityModel();
      JsonObject jsonObject = new JsonObject();
      JsonArray vulnerabilitiesJson = new JsonArray();

      GsonBuilder gson_builder = new GsonBuilder();
      Gson gson = gson_builder.create();


      for (SestVulnerability vulnerability : vulnerabilities) {

        LOG.info("getVulnerabilityRepository -  vulnerability: " + vulnerability.getVulnerabilityJson());

        JsonElement element = gson.fromJson(vulnerability.getVulnerabilityJson(), JsonElement.class);
        vulnerabilitiesJson.add(element);

      }
      jsonObject.add("vulnerabilities", vulnerabilitiesJson);
      jsonObject.addProperty("creationTime", "");
      jsonObject.addProperty("updateTime", "");
      jsonObject.addProperty("identifier", "");
      jsonObject.addProperty("objType", "VulnerabilityModel");

      GsonBuilder gsonBuilder = new GsonBuilder();

      gson = gsonBuilder.setPrettyPrinting().disableHtmlEscaping().create();
      vulnModel.setVulnerabilityModelJson(gson.toJson(jsonObject));

      LOG.info("getVulnerabilityRepository -  Vulnerability Model returned: " + vulnModel);
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
      return null;
    } finally {
      sqlSession.close();
    }

    return vulnModel;
  }

  @Override
  public boolean updateVulnerabilityRepository(VulnerabilityModel vmToAdd, VulnerabilityModel vmToUpdate) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("updateVulnerabilityRepository");

    try {
      //create a new Vulnerability Mapper
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);

      SestobjMapper sestobjMapper = sqlSession.getMapper(SestobjMapper.class);

      for (Vulnerability newVulnerability : vmToAdd.getVulnerabilities()) {
        LOG.info("Insert sestObject");
        Sestobj sestobj = null;
        sestobj = new Sestobj();
        sestobj.setObjtype(SESTObjectTypeEnum.VulnerabilityRef.name());
        UUID uuid = UUID.randomUUID();
        sestobj.setIdentifier(uuid.toString());
        newVulnerability.setIdentifier(uuid.toString());
        sestobjMapper.insertWithIdentifier(sestobj);


        LOG.info("Insert vulnerability - sestObjectId " + uuid.toString());
        VulnerabilitySerializerDeserializer vulnSerializer = new VulnerabilitySerializerDeserializer();
        String vulnJson = vulnSerializer.getJSONStringFromVM(newVulnerability);

        DateFormat df = new SimpleDateFormat(DD_MM_YYYY_HH_MM);
        Date vulnerabilityDate = df.parse(newVulnerability.getLastUpdate());

        SestVulnerability vuln = new SestVulnerability();
        vuln.setScoringType(newVulnerability.getScore().getScoringType().toString());
        vuln.setScore(newVulnerability.getScore().getScore().toString());
        vuln.setExploitability(newVulnerability.getScore().getExploitability().toString());
        vuln.setPhase(newVulnerability.getPhase().toString());
        vuln.setName(newVulnerability.getName());
        vuln.setDamage(newVulnerability.getDescription());
        vuln.setUpdateTime(vulnerabilityDate);
        vuln.setCatalogueId(newVulnerability.getCatalogueId());
        vuln.setCatalogue(newVulnerability.getCatalogue().toString());
        vuln.setVulnerabilityJson(vulnJson);
        vuln.setSestobjId(newVulnerability.getIdentifier());

        for (SecondaryAssetCategoryEnum secondaryAsset : newVulnerability.getAffectedAssetsCategories()) {
          vuln.getSecondaryAssetCategory().add(secondaryAsset.toString());
        }

        vulnerabilityMapper.insertVulnerabilityRepository(vuln);

        for (String secondaryAssetCategory : vuln.getSecondaryAssetCategory()) {
          vulnerabilityMapper.insertVulnerabilityAssetRepository(vuln.getSestobjId(), secondaryAssetCategory);
        }
      }

      for (Vulnerability newVulnerability : vmToUpdate.getVulnerabilities()) {

        LOG.info("Update vulnerability - sestObjectId " + newVulnerability.getIdentifier());
        SestVulnerability sestVulnerability = new SestVulnerability();
        sestVulnerability.convertFromModel(newVulnerability);

        DateFormat df = new SimpleDateFormat(DD_MM_YYYY_HH_MM);
        Date vulnerabilityDate = df.parse(newVulnerability.getLastUpdate());
        sestVulnerability.setUpdateTime(vulnerabilityDate);

        VulnerabilitySerializerDeserializer vulnSerializer = new VulnerabilitySerializerDeserializer();
        String vulnerabilityJson = vulnSerializer.getJSONStringFromVM(newVulnerability);
        sestVulnerability.setVulnerabilityJson(vulnerabilityJson);

        vulnerabilityMapper.updateVulnerabilityRepository(sestVulnerability);
        vulnerabilityMapper.deleteVulnerabilityAssetRepository(newVulnerability.getIdentifier());

        for (SecondaryAssetCategoryEnum secondaryAssetCategory : newVulnerability.getAffectedAssetsCategories()) {
          vulnerabilityMapper.insertVulnerabilityAssetRepository(newVulnerability.getIdentifier(), secondaryAssetCategory.toString());
        }
      }

      LOG.info("updateVulnerabilityRepository end");
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage(), ex);
      sqlSession.rollback();
      return false;
    } finally {
      sqlSession.close();
    }
    return true;
  }

  @Override
  public Integer retrieveVulnerabilityReferenceId(String catalogueId) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("retrieveVulnerabilityReferenceId");
    Integer vulnRepElementId = null;

    try {
      //create a new Vulnerability Mapper
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      // retrieve the element into VULNERABILITY table that matches all the input fields
      vulnRepElementId = vulnerabilityMapper.getVulnerabilityReferenceIdByCatalogueId(catalogueId);

      LOG.info("retrieveVulnerabilityReferenceId end");
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
      return null;
    } finally {
      sqlSession.close();
    }

    return vulnRepElementId;
  }

  public String insertVulnerabilityReference(Vulnerability vulnerabilityModelJson) throws Exception {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("insert " + vulnerabilityModelJson.getCatalogueId());
    SestVulnerability sestVulnerability = new SestVulnerability();
    try {
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      sestVulnerability.convertFromModel(vulnerabilityModelJson);

      Integer alreadyExitingVulnerability = vulnerabilityMapper.getVulnerabilityReferenceIdByCatalogueId(sestVulnerability.getCatalogueId());
      if (alreadyExitingVulnerability != null) {
        LOG.error("Already existing vulnerability with catalogue id : " + sestVulnerability.getCatalogueId());
        throw new Exception("Already existing vulnerability with catalogue id : " + sestVulnerability.getCatalogueId());
      }

      Sestobj sestobj = new Sestobj();
      sestobj.setObjtype(SESTObjectTypeEnum.VulnerabilityRef.name());
      sestobj.setIdentifier(UUID.randomUUID().toString());
      SestobjMapper sestobjMapper = sqlSession.getMapper(SestobjMapper.class);
      sestobjMapper.insertWithIdentifier(sestobj);
      sestVulnerability.setSestobjId(sestobj.getIdentifier());

      VulnerabilitySerializerDeserializer vulnSerializer = new VulnerabilitySerializerDeserializer();
      vulnerabilityModelJson.setIdentifier(sestobj.getIdentifier());
      vulnerabilityModelJson.setObjType(SESTObjectTypeEnum.VulnerabilityRef);

      DateFormat df = new SimpleDateFormat(DD_MM_YYYY_HH_MM);
      vulnerabilityModelJson.setLastUpdate(df.format(new Date()));
      String vulnerabilityJson = vulnSerializer.getJSONStringFromVM(vulnerabilityModelJson);
      sestVulnerability.setVulnerabilityJson(vulnerabilityJson);
      sestVulnerability.setUpdateTime(new Date());

      vulnerabilityMapper.insertVulnerabilityRepository(sestVulnerability);
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage(), ex);
      sqlSession.rollback();
      throw ex;
    } finally {
      sqlSession.close();
    }
    return sestVulnerability.getSestobjId();
  }

  public void deleteVulnerabilityReference(List<String> identifier) {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("delete " + identifier);
    try {
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);
      vulnerabilityMapper.deleteVulnerabilityReference(identifier);
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
      throw ex;
    } finally {
      sqlSession.close();
    }
  }

  public void editVulnerabilityReference(Vulnerability vulnerabilityModelJson) throws Exception {
    SqlSession sqlSession = sessionFactory.getSession();
    LOG.info("edit " + vulnerabilityModelJson.getCatalogueId());
    LOG.info("edit " + vulnerabilityModelJson.getIdentifier());
    try {
      VulnerabilityMapper vulnerabilityMapper = sqlSession.getMapper(VulnerabilityMapper.class);

      SestVulnerability sestVulnerability = new SestVulnerability();
      sestVulnerability.convertFromModel(vulnerabilityModelJson);

      String alreadyExitingVulnerabilityIdentifier = vulnerabilityMapper.getVulnerabilityReferenceSestObjIdByCatalogueId(sestVulnerability.getCatalogueId());
      if (alreadyExitingVulnerabilityIdentifier != null && !alreadyExitingVulnerabilityIdentifier.equals(vulnerabilityModelJson.getIdentifier())) {
        LOG.error("Already existing vulnerability with catalogue id : " + sestVulnerability.getCatalogueId());
        throw new Exception("Already existing vulnerability with catalogue id : " + sestVulnerability.getCatalogueId());
      }

      VulnerabilitySerializerDeserializer vulnSerializer = new VulnerabilitySerializerDeserializer();
      DateFormat df = new SimpleDateFormat(DD_MM_YYYY_HH_MM);
      vulnerabilityModelJson.setLastUpdate(df.format(new Date()));
      String vulnerabilityJson = vulnSerializer.getJSONStringFromVM(vulnerabilityModelJson);
      sestVulnerability.setVulnerabilityJson(vulnerabilityJson);
      sestVulnerability.setUpdateTime(new Date());

      vulnerabilityMapper.updateVulnerabilityRepository(sestVulnerability);
      sqlSession.commit();
    } catch (Exception ex) {
      LOG.error(ex.getMessage());
      sqlSession.rollback();
      throw ex;
    } finally {
      sqlSession.close();
    }
  }

  public PersistencySessionFactory getSessionFactory() {
    return sessionFactory;
  }

  public void setSessionFactory(PersistencySessionFactory sessionFactory) {
    this.sessionFactory = sessionFactory;
  }
}
